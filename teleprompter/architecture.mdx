---
title: "Architecture & Tech Stack"
description: "Deep dive into the technical architecture, data flow, and technology choices powering the teleprompter app"
---

## Technology Stack

Our teleprompter is built with carefully selected modern technologies that prioritize performance, developer experience, and cross-platform compatibility.

### Frontend Layer

<CardGroup cols={3}>
<Card title="React 19" icon="react">
  Latest React with concurrent features for smooth UI updates and optimal rendering performance
</Card>

<Card title="TypeScript" icon="code">
  Type safety and enhanced developer experience with intelligent autocomplete and error detection
</Card>

<Card title="Vite 7" icon="bolt">
  Lightning-fast Hot Module Replacement (HMR) for instant feedback during development
</Card>
</CardGroup>

### Backend Layer

<CardGroup cols={3}>
<Card title="Tauri 2.0" icon="window-restore">
  Rust-powered desktop frameworkâ€”smaller, faster, and more secure than Electron
</Card>

<Card title="Rust" icon="rust">
  Memory-safe systems programming for file operations and window management
</Card>

<Card title="Native Plugins" icon="puzzle-piece">
  Global shortcuts, file system access, and OS-level integrations
</Card>
</CardGroup>

### Additional Technologies

<Tabs>
<Tab title="MCP Server">
  **Model Context Protocol** for AI-assisted script editing and intelligent suggestions
  
  - Real-time content analysis
  - Writing assistance
  - Script optimization
</Tab>

<Tab title="File Watching">
  **Real-time monitoring** for instant updates when scripts are edited externally
  
  - Sub-100ms detection
  - Cross-platform support
  - Minimal resource usage
</Tab>

<Tab title="MongoDB">
  **Cloud integration** for script storage and synchronization
  
  - Multi-device access
  - Version history
  - Collaborative features
</Tab>
</Tabs>

## Why This Stack? ğŸ¤”

### 1. Performance That Matters

<Tip>
Choosing Tauri over Electron reduces binary size by ~10x and significantly improves startup time and memory efficiency.
</Tip>

**Key Performance Benefits:**

- **Binary Size:** Tauri apps are typically 3-10MB vs Electron's 100-200MB
- **Memory Footprint:** 20-50MB RAM vs Electron's 200-500MB
- **Native Performance:** Direct OS API access without JavaScript bridge overhead
- **Fast Startup:** Cold start in <2 seconds

### 2. Real-Time Architecture

The application is designed for instant responsiveness:

```typescript
// Real-time file watching implementation
const watcher = await watch('scripts/**/*.{txt,md}', {
  recursive: true,
  delayMs: 50  // Near-instant detection
});

watcher.on('change', async (path) => {
  const content = await readFile(path);
  updateTeleprompterDisplay(content);
});
```

<Check>
Changes to scripts are detected and displayed in under 100ms, providing a seamless editing experience.
</Check>

### 3. Cross-Platform Native Feel

Each platform gets native window management and OS integrations:

<CodeGroup>
```rust Windows
use tauri::window::WindowBuilder;

WindowBuilder::new(app, "main", tauri::WindowUrl::default())
    .decorations(false)
    .transparent(true)
    .always_on_top(true)
    .skip_taskbar(true)
    .build()?;
```

```rust macOS
WindowBuilder::new(app, "main", tauri::WindowUrl::default())
    .title_bar_style(TitleBarStyle::Overlay)
    .hidden_title(true)
    .transparent(true)
    .build()?;
```

```rust Linux
WindowBuilder::new(app, "main", tauri::WindowUrl::default())
    .decorations(false)
    .transparent(true)
    .always_on_top(true)
    .build()?;
```
</CodeGroup>

## System Architecture

The application follows a clean separation of concerns between the UI layer and system operations.

### High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   React Frontend (TypeScript)       â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚   - UI Components & State           â”‚
â”‚   - Real-time Scroll Engine         â”‚
â”‚   - Settings Management             â”‚
â”‚   - Event Handling                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ 
              â”‚ Tauri IPC (JSON-RPC)
              â”‚ Type-safe bidirectional
              â”‚ communication
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Rust Backend (Tauri Core)         â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚   - File System Operations          â”‚
â”‚   - Window Management (Borderless)  â”‚
â”‚   - Global Shortcut Registration    â”‚
â”‚   - Real-time File Watcher          â”‚
â”‚   - Native Plugin System            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â”‚ Direct OS APIs
              â”‚ Zero-overhead syscalls
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Operating System Layer            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚
â”‚   - Native Window Control           â”‚
â”‚   - Keyboard Hook Integration       â”‚
â”‚   - File System Events              â”‚
â”‚   - Display Management              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Component Breakdown

<AccordionGroup>
<Accordion title="Frontend Components" icon="react">
  **React Component Hierarchy:**
  
  ```
  App
  â”œâ”€â”€ TeleprompterDisplay
  â”‚   â”œâ”€â”€ ScrollContainer
  â”‚   â”œâ”€â”€ FocusBand
  â”‚   â””â”€â”€ CountdownTimer
  â”œâ”€â”€ SettingsPanel
  â”‚   â”œâ”€â”€ AppearanceSettings
  â”‚   â”œâ”€â”€ BehaviorSettings
  â”‚   â””â”€â”€ ShortcutSettings
  â”œâ”€â”€ FileManager
  â”‚   â”œâ”€â”€ ScriptList
  â”‚   â”œâ”€â”€ FileUploader
  â”‚   â””â”€â”€ ScriptEditor
  â””â”€â”€ ControlBar
      â”œâ”€â”€ PlaybackControls
      â”œâ”€â”€ SpeedControl
      â””â”€â”€ ModeSelector
  ```
  
  Each component is optimized with React.memo and proper hook usage to prevent unnecessary re-renders.
</Accordion>

<Accordion title="Backend Services" icon="server">
  **Rust Service Architecture:**
  
  - **File Service:** Handles all file I/O operations
  - **Window Service:** Manages window states and properties
  - **Shortcut Service:** Registers and handles global keyboard shortcuts
  - **Watcher Service:** Monitors file system for changes
  - **Settings Service:** Persists and loads user preferences
  
  All services communicate via Tauri's command system with type-safe interfaces.
</Accordion>

<Accordion title="IPC Communication" icon="arrows-left-right">
  **Type-Safe Frontend â†” Backend Communication:**
  
  ```typescript
  // Frontend: Invoke Rust command
  import { invoke } from '@tauri-apps/api/tauri';
  
  const scripts = await invoke<string[]>('load_scripts', {
    directory: '/path/to/scripts'
  });
  ```
  
  ```rust
  // Backend: Command handler
  #[tauri::command]
  async fn load_scripts(directory: String) -> Result<Vec<String>, String> {
      // Implementation
  }
  ```
</Accordion>
</AccordionGroup>

## Real-Time Data Flow

Understanding how data flows through the system helps appreciate the architecture's efficiency.

### Example: External Script Edit Flow

<Steps>
<Step title="User edits script externally">
  User opens a script file in VS Code, Notepad, or any text editor and makes changes
  
  ```bash
  # Example: User edits presentation.txt
  echo "Additional paragraph" >> scripts/presentation.txt
  ```
</Step>

<Step title="Rust file watcher detects change">
  The Rust-based file watcher receives an OS-level file system event
  
  ```rust
  // Rust backend receives FS event
  watcher.on_change(|event| {
      match event.kind {
          EventKind::Modify(_) => {
              emit_to_frontend("file-changed", event.path);
          }
      }
  });
  ```
  
  <Check>
  Detection latency: ~10-50ms depending on OS
  </Check>
</Step>

<Step title="Event emitted to frontend">
  Rust emits an event to the React frontend via Tauri's event system
  
  ```typescript
  // React receives event
  import { listen } from '@tauri-apps/api/event';
  
  listen('file-changed', async (event) => {
      const content = await invoke('read_file', { 
        path: event.payload 
      });
      setScriptContent(content);
  });
  ```
</Step>

<Step title="React state updates">
  React's state management triggers a component re-render
  
  ```typescript
  const [scriptContent, setScriptContent] = useState('');
  
  // State update triggers re-render
  // Only affected components re-render due to React.memo
  ```
</Step>

<Step title="UI refreshes instantly">
  The teleprompter display updates with new content
  
  <Check>
  Total latency from file save to display: **<100ms**
  </Check>
</Step>
</Steps>

## Performance Optimizations

### Frontend Optimizations

<CodeGroup>
```typescript React Memoization
import { memo, useMemo, useCallback } from 'react';

export const ScrollContainer = memo(({ 
  content, 
  speed, 
  onScroll 
}) => {
  const scrollStyle = useMemo(() => ({
    transform: `translateY(${offset}px)`,
    transition: 'transform 0.016s linear'
  }), [offset]);
  
  return <div style={scrollStyle}>{content}</div>;
});
```

```typescript RAF Scrolling
const scrollTick = useCallback(() => {
  if (!isPlaying) return;
  
  const pixelsPerFrame = (wpm * avgWordLength) / (60 * 60);
  setOffset(prev => prev + pixelsPerFrame);
  
  requestAnimationFrame(scrollTick);
}, [isPlaying, wpm]);
```
</CodeGroup>

### Backend Optimizations

```rust
// Efficient file reading with memory mapping
use memmap2::Mmap;
use std::fs::File;

fn read_large_script(path: &str) -> Result<String, Error> {
    let file = File::open(path)?;
    let mmap = unsafe { Mmap::map(&file)? };
    let content = std::str::from_utf8(&mmap)?;
    Ok(content.to_string())
}
```

<Tip>
Memory-mapped file I/O in Rust provides near-instant access to large script files without loading them entirely into RAM.
</Tip>

## Security Architecture

### Tauri Security Features

<Warning>
Tauri's security model is more restrictive than Electron, providing better protection against common vulnerabilities.
</Warning>

- **No Node.js runtime** - Reduces attack surface significantly
- **Capability-based security** - Explicit permissions for each API
- **Content Security Policy** - Prevents XSS attacks
- **Command allowlist** - Only explicitly allowed commands can be invoked

```json
// tauri.conf.json security configuration
{
  "security": {
    "csp": "default-src 'self'; script-src 'self' 'unsafe-inline'",
    "dangerousRemoteDomainIpcAccess": [],
    "freezePrototype": true
  },
  "allowlist": {
    "fs": {
      "scope": ["$APPDATA/scripts/**"]
    }
  }
}
```

---

<Info>
This architecture ensures the teleprompter app delivers professional-grade performance while maintaining security and cross-platform compatibility.
</Info>
